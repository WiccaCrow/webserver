DESCRIPTION
       poll() performs a similar task to select(2): it waits for one of a set of file descriptors
       to become ready to perform I/O.

       The set of file descriptors to be monitored is specified in the fds argument, which is  an
       array of structures of the following form:

           struct pollfd {
               int   fd;         // file descriptor 
               short events;     // requested events 
               short revents;    // returned events 
           };

       The caller should specify the number of items in the fds array in nfds.

       The field fd contains a file descriptor for an open file.  If this field is negative, then
       the corresponding events field is ignored and the revents field returns zero.  (This  pro‐
       vides  an  easy  way of ignoring a file descriptor for a single poll() call: simply negate
       the fd field.  Note, however, that this technique can't be used to ignore file  descriptor
       0.)

       The  field  events is an input parameter, a bit mask specifying the events the application
       is interested in for the file descriptor fd.  This field may  be  specified  as  zero,  in
       which case the only events that can be returned in revents are POLLHUP, POLLERR, and POLL‐
       NVAL (see below).

       The field revents is an output parameter, filled by the kernel with the events that  actu‐
       ally occurred.  The bits returned in revents can include any of those specified in events,
       or one of the values POLLERR, POLLHUP, or POLLNVAL.  (These three bits are meaningless  in
       the  events  field, and will be set in the revents field whenever the corresponding condi‐
       tion is true.)

       If none of the events requested (and no error) has occurred for any of the  file  descrip‐
       tors, then poll() blocks until one of the events occurs.

       The timeout argument specifies the number of milliseconds that poll() should block waiting
       for a file descriptor to become ready.  The call will block until either:

       *  a file descriptor becomes ready;

       *  the call is interrupted by a signal handler; or

       *  the timeout expires.

       Note that the timeout interval will be rounded up to the  system  clock  granularity,  and
       kernel  scheduling  delays  mean that the blocking interval may overrun by a small amount.
       Specifying a negative value in timeout means an infinite timeout.  Specifying a timeout of
       zero causes poll() to return immediately, even if no file descriptors are ready.

       The bits that may be set/returned in events and revents are defined in <poll.h>:

       POLLIN There is data to read.

       POLLOUT
              Writing is now possible, though a write larger that the available space in a socket
              or pipe will still block (unless O_NONBLOCK is set).

       POLLERR
              Error  condition  (only  returned in revents; ignored in events).  This bit is also
              set for a file descriptor referring to the write end of a pipe when  the  read  end
              has been closed.

       POLLHUP
              Hang up (only returned in revents; ignored in events).  Note that when reading from
              a channel such as a pipe or a stream socket, this event merely indicates  that  the
              peer  closed its end of the channel.  Subsequent reads from the channel will return
              0 (end of file) only after all outstanding data in the channel has been consumed.

       POLLNVAL
              Invalid request: fd not open (only returned in revents; ignored in events).


RETURN VALUE
       On  success,  a  positive  number is returned; this is the number of structures which have
       nonzero revents fields (in other words, those descriptors with events or errors reported).
       A value of 0 indicates that the call timed out and no file descriptors were ready.  On er‐
       ror, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT The array given as argument was not contained  in  the  calling  program's  address
              space.

       EINTR  A signal occurred before any requested event; see signal(7).

       EINVAL The nfds value exceeds the RLIMIT_NOFILE value.

       ENOMEM There was no space to allocate file descriptor tables.

NOTES
       The operation of poll() and ppoll() is not affected by the O_NONBLOCK flag.

       On some other UNIX systems, poll() can fail with the error EAGAIN if the system  fails  to
       allocate  kernel-internal resources, rather than ENOMEM as Linux does.  POSIX permits this
       behavior.  Portable programs may wish to check for EAGAIN and loop, just as with EINTR.

       Some implementations define the nonstandard constant INFTIM with the value -1 for use as a
       timeout for poll().  This constant is not provided in glibc.

       For  a  discussion  of  what  may happen if a file descriptor being monitored by poll() is
       closed in another thread, see select(2).



MY_NOTES 
       POLLNVAL is equivalent to EBADF: it means the file descriptor does not actually refer to any open file, 
       i.e. it was closed or never open to begin with. This can never happen except as a result of a programming error 
       or intentional attempt to query whether a file descriptor is invalid. External conditions, 
       such as a peer closing its end of a network socket or pipe, can never close your file descriptor to your end of the socket or pipe.
        If it could, this would lead to massive vulnerabilities in basically any program using sockets/pipes/etc.

       OLLHUP, on the other hand, indicates that your file descriptor is valid, but that it's in a state where:

       A device has been disconnected, or a pipe or FIFO has been closed by the last process that had it open for writing.
        Once set, the hangup state of a FIFO shall persist until some process opens the FIFO for writing 
        or until all read-only file descriptors for the FIFO are closed. This event and POLLOUT are mutually-exclusive; 
        a stream can never be writable if a hangup has occurred. However, this event and POLLIN, POLLRDNORM, POLLRDBAND, 
        or POLLPRI are not mutually-exclusive. This flag is only valid in the revents bitmask; it shall be ignored in the events member.

       If you want to see POLLHUP, simply open a pipe, close the reading end, and query the writing end with poll.